{
  "hash": "31dd89189833687a3a62c74746dda977",
  "result": {
    "engine": "knitr",
    "markdown": "# Descriptive statistics\n\n\n::: {.cell}\n\n:::\n\n\n\n## Continuous variables \nProducing descriptive statistics in R is relatively straightforward, as key functions are included by default in the Base package. We have already seen above that the `summary()` command provides essential information about a variable. For instance,\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bsa$leftrigh)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   1.00    2.00    2.40    2.52    3.00    5.00     782 \n```\n\n\n:::\n:::\n\n\nprovides  information about the mean, median and quartiles of the political scale of respondents.\n\nThe `describe()` command from  the `Hmisc` package provides a more detailed set of summary statistics. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Hmisc)\ndescribe(bsa$leftrigh)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in proxy[, ..., drop = FALSE]: incorrect number of dimensions\n```\n\n\n:::\n:::\n\n\nThe code above returns an error because `describe()` expects numeric values, and  *haven*-converted 'leftrigh' isn't a pure numeric variable: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(bsa$leftrigh)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"haven_labelled\" \"vctrs_vctr\"     \"double\"        \n```\n\n\n:::\n:::\n\n\nIn order for `describe()` to run properly, we need to convert `leftrigh`  to numeric format, either as a new variable or as below, temporarily: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndescribe(as.numeric(bsa$leftrigh))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nas.numeric(bsa$leftrigh) \n       n  missing distinct     Info     Mean      Gmd      .05      .10 \n    3206      782       30    0.993     2.52   0.8831      1.2      1.4 \n     .25      .50      .75      .90      .95 \n     2.0      2.4      3.0      3.6      4.0 \n\nlowest : 1    1.2  1.4  1.5  1.6 , highest: 4.4  4.6  4.75 4.8  5   \n```\n\n\n:::\n:::\n\n\n\n\n`describe()` also provides the number of observations (including missing and unique observations), deciles as well as the five largest and smallest values.\n\nCommands producing single  statistics are also available:\n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(bsa$leftrigh, na.rm = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.519911\n```\n\n\n:::\n\n```{.r .cell-code}\nsd(bsa$leftrigh, na.rm = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.7852958\n```\n\n\n:::\n\n```{.r .cell-code}\nmedian(bsa$leftrigh, na.rm = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.4\n```\n\n\n:::\n\n```{.r .cell-code}\nmax(bsa$leftrigh, na.rm = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<labelled<double>[1]>: Left-right scale(redistrb to indust4) dv\n[1] 5\n\nLabels:\n value              label\n    -1 No self-completion\n     1               left\n     5              right\n     9     Missing values\n```\n\n\n:::\n\n```{.r .cell-code}\nmin(bsa$leftrigh, na.rm = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<labelled<double>[1]>: Left-right scale(redistrb to indust4) dv\n[1] 1\n\nLabels:\n value              label\n    -1 No self-completion\n     1               left\n     5              right\n     9     Missing values\n```\n\n\n:::\n:::\n\n\n\nWe could  combine the output from the above commands into a single line using the `c()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\n  mean(bsa$leftrigh, na.rm = T),\n  sd(bsa$leftrigh, na.rm = T),\n  median(bsa$leftrigh, na.rm = T),\n  max(bsa$leftrigh, na.rm = T),\n  min(bsa$leftrigh, na.rm = T)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.5199106 0.7852958 2.4000000 5.0000000 1.0000000\n```\n\n\n:::\n:::\n\n\n\nAs we saw previously, the `na.rm = T` option prevents missing values from being taken into account (in which case the output would have been NA, as this is the default behaviour of these functions). Using these individual commands may come in handy, for instance when further processing of the result is needed:\n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- mean(bsa$leftrigh, na.rm= T)\n```\n:::\n\n\n\nLet’s round the results to two decimal places:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm <- round(m,2)\n```\n:::\n\n\n\nWe can see the final results by typing:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.52\n```\n\n\n:::\n:::\n\n\n\nNote: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(mean(bsa$leftrigh,na.rm=T),2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.52\n```\n\n\n:::\n:::\n\n\n\nwould produce the same results using just one line of code .\n\n## Bivariate association between continuous variables\nR provides a wide range of bivariate statistics under its base packages. The cor() and  cov() functions provide basic measures of association between two variables. For instance, in order to measure the correlation between the leftright scale and the libertarian-authoritarian scale: The later variable is a numeric variable that details how far someone sits on the libartrian – authoritarian scale from 1 to 5\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncor(bsa$leftrigh, bsa$libauth, use='complete.obs')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.009625928\n```\n\n\n:::\n:::\n\n\n\nA correlation of 0.009 indicates an positive but very small relationship. It can be translated to mean ‘an increase in authoritarianism is associated with a marginal increase  in rightwing views.\n\nNote: When using the cor() and cov() functions  missing values are dealt with the ‘use=’ \"everything\", \"all.obs\", \"complete.obs\", \"na.or.complete\", or \"pairwise.complete.obs\" options. See ‘?cor’  for additional information.\n\n\n\n## Categorical Variables\nAs with continuous variables, R offers several tools that can be used to describe the distribution of categorical variables. One- and two-way contingency tables are the most commonly used.\n\n### One way frequency tables\nThere are several R commands that we can use to create frequency tables. The most common ones `table()`,`xtabs()` or `ftable()` which return the frequencies of observations within each level of a factor. For example, in order to obtain the political affiliation of BSA respondents in 2017:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(as_factor(bsa$PartyId2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n     Not applicable        Conservative              Labour    Liberal Democrat \n                  0                1263                1479                 241 \n        Other party                None         Green Party Other answer/DK/Ref \n                193                 515                  79                   0 \n```\n\n\n:::\n:::\n\n\n\nAs with any other R functions, the outcome of `table()` can be stored as an object for further processing:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na<-table(as_factor(bsa$PartyId2))\n```\n:::\n\n\n\n\n`table()` does not compute proportions or percentages. Proportions are obtained using the `prop.table()` function which in turn does not produce percentages. It is also a good idea to round the results for greater readability.\nEither:\n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(\n  100*\n    prop.table(a),\n  1) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n     Not applicable        Conservative              Labour    Liberal Democrat \n                0.0                33.5                39.2                 6.4 \n        Other party                None         Green Party Other answer/DK/Ref \n                5.1                13.7                 2.1                 0.0 \n```\n\n\n:::\n:::\n\n\n... or:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(100*\n        prop.table(\n          table(as_factor(bsa$PartyId2))\n        ),\n      1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n     Not applicable        Conservative              Labour    Liberal Democrat \n                0.0                33.5                39.2                 6.4 \n        Other party                None         Green Party Other answer/DK/Ref \n                5.1                13.7                 2.1                 0.0 \n```\n\n\n:::\n:::\n\n\n\n### Two way or more contingency table\n\nThe simplest way to produce a two-way contingency table is to pass another variable to `table()`:\n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(as_factor(bsa$PartyId2), as_factor(bsa$Rsex))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                     \n                      skipped or na Male Female Dontknow Refusal\n  Not applicable                  0    0      0        0       0\n  Conservative                    0  627    636        0       0\n  Labour                          0  644    835        0       0\n  Liberal Democrat                0  124    117        0       0\n  Other party                     0   97     96        0       0\n  None                            0  199    316        0       0\n  Green Party                     0   31     48        0       0\n  Other answer/DK/Ref             0    0      0        0       0\n```\n\n\n:::\n:::\n\n\n\nHowever, when dealing with more than one variable it is recommended to use `xtabs()` instead as it has a number of desirable functions directly available as options. The syntax is slightly different as it relies on a `formula` ie a R object consisting of elements separated by a tilde '~'. The variables to be tabulated are specified on the right hand side of the formula. In order to lighten the syntax, we will also recode `PartyId2` and `Rsex` permanently into factors. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbsa$PartyId2.f<-as_factor(bsa$PartyId2)\nbsa$Rsex.f<-as_factor(bsa$Rsex)\n\nxtabs(~PartyId2.f +Rsex.f,\n      data = bsa)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                     Rsex.f\nPartyId2.f            skipped or na Male Female Dontknow Refusal\n  Not applicable                  0    0      0        0       0\n  Conservative                    0  627    636        0       0\n  Labour                          0  644    835        0       0\n  Liberal Democrat                0  124    117        0       0\n  Other party                     0   97     96        0       0\n  None                            0  199    316        0       0\n  Green Party                     0   31     48        0       0\n  Other answer/DK/Ref             0    0      0        0       0\n```\n\n\n:::\n:::\n\n\nThe `data=` parameter does not have to be explicitly specified as simply using ´`bsa`' will work. Other useful options are:\n\n- `subset=`, which allows direct specification of a subpopulation from which to derive the table;\n- `drop.unused.levels=T` to remove empty levels (categories with zero observations) from being displayed;\n- `weights~` variables on the right hand side of the formula will be treated as weights, a useful feature for survey analysis. \n\nAs previously `prop.table()` is necessary in order to obtain proportions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb<-xtabs(~PartyId2.f +Rsex.f,\n         bsa,\n         drop.unused.levels = T)\n\nround(100*\n        prop.table(b),\n      1) ### Cell percentages\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                  Rsex.f\nPartyId2.f         Male Female\n  Conservative     16.6   16.9\n  Labour           17.1   22.1\n  Liberal Democrat  3.3    3.1\n  Other party       2.6    2.5\n  None              5.3    8.4\n  Green Party       0.8    1.3\n```\n\n\n:::\n:::\n\n\nThe largest group in the sample (22.1%) is made of labour-voting females, the smallest of green-voting males.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(100*\n        prop.table(b,1),\n      1) ### Option 1 for row percentages\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                  Rsex.f\nPartyId2.f         Male Female\n  Conservative     49.6   50.4\n  Labour           43.5   56.5\n  Liberal Democrat 51.5   48.5\n  Other party      50.3   49.7\n  None             38.6   61.4\n  Green Party      39.2   60.8\n```\n\n\n:::\n:::\n\n\nConservative voters are more or less evenly split between men and women, whereas Labour and Green voters are more likely to be women.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(100*\n        prop.table(b,2),\n      1) ### Option 2 for column percentages\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                  Rsex.f\nPartyId2.f         Male Female\n  Conservative     36.4   31.1\n  Labour           37.4   40.8\n  Liberal Democrat  7.2    5.7\n  Other party       5.6    4.7\n  None             11.6   15.4\n  Green Party       1.8    2.3\n```\n\n\n:::\n:::\n\n\nSimilar proportions of men voted Conservative and Labour (36-37%), whereas women were clearly more likely to vote Labour.\n\nThere is not a straightforward way to obtain percentages in three-way contingency tables with either `xtabs()` or `table()`. This is where `ftable()` function comes handy. For convenience, we remove the non response.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbsa$RAgeCat.f<-as_factor(bsa$RAgeCat) # We convert RAgeCat into facto for convenience\n\nround(100*\n        prop.table(\n          ftable(RAgeCat.f~PartyId2.f+Rsex.f,\n                 data=droplevels(bsa)\n                   )\n         ,1)\n      ,1) ### Option 2 for column percentages\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                        RAgeCat.f 18-24 25-34 35-44 45-54 55-59 60-64  65+\nPartyId2.f       Rsex.f                                                   \nConservative     Male               3.0   7.8  13.9  15.0   8.6   9.3 42.4\n                 Female             2.7   7.1   8.8  18.6   8.8   8.7 45.4\nLabour           Male               7.6  16.1  14.3  21.3   7.5   9.3 23.9\n                 Female             7.9  20.2  19.2  18.8   7.1   7.1 19.7\nLiberal Democrat Male               0.8  13.7  19.4  15.3   9.7   8.9 32.3\n                 Female             4.3   9.4  26.5   6.0   6.0   9.4 38.5\nOther party      Male               3.1  14.4  11.3  17.5  11.3  16.5 25.8\n                 Female             5.2  14.6  15.6  16.7  11.5   8.3 28.1\nNone             Male               7.5  22.1  20.6  17.1  11.1   6.0 15.6\n                 Female             8.5  22.5  20.6  21.8   7.3   6.3 13.0\nGreen Party      Male               6.5  32.3  16.1  29.0   6.5   3.2  6.5\n                 Female             6.2  18.8  25.0  20.8   6.2  10.4 12.5\n```\n\n\n:::\n:::\n\n\nThe tables gives the relative age breakdown for each gender/political affiliation combination (ie row percentages). Please not that we have used the `droplevels()` function when spcecifying the BSA data frame within `ftble()`. This removes unused factor levels which would otherwise be  displayed and make the table difficult to read. `droplevels()` can be applied either to entire data frames or single variables.    \n\n\n\n## Grouped summary statistics for continuous variables\nA common requirement in survey analysis consist in being able to compare  descriptive statistics across subgroups of the data. There are different ways to do this in R. We demonstrate below the most straightforward  one, which is obtained by using some of the functions available in the `dplyr` package. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbsa%>%\n  group_by(PartyId2.f)%>%\n  summarise(mdscore=median(libauth,na.rm=T),\n            sdscore=sd(libauth,na.rm=T))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 x 3\n  PartyId2.f       mdscore sdscore\n  <fct>              <dbl>   <dbl>\n1 Conservative        3.67   0.587\n2 Labour              3.33   0.774\n3 Liberal Democrat    3.17   0.726\n4 Other party         3.67   0.739\n5 None                3.67   0.584\n6 Green Party         2.83   0.872\n7 <NA>                3.67   0.564\n```\n\n\n:::\n:::\n\n\n\nThe above command produces a table of summary values (median and standard deviations) of the Liberal vs authoritarian scale. We can see from the first one that Green party voters are the most liberal, followed by Labour, whereas non voters and Conservatives are the most authoritarian. Liberal Democrats are the most cohesive group (ie with the smallest standard deviation). We chose to leave nonresponses for  `PartyId2` for this analysis. Some users might want to remove them instead before computing their results as in the table below.  We do this by using `is.na()`, which checks variables for the presence of system missing values, in conjunction with `filter()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbsa%>%\n  filter(!is.na(PartyId2.f)) %>%                              \n  group_by(Rsex.f,PartyId2.f) %>%\n  summarise(mnscore=sd(libauth,na.rm=T),\n            mdscore=median(libauth,na.rm=T))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 4\n# Groups:   Rsex.f [2]\n   Rsex.f PartyId2.f       mnscore mdscore\n   <fct>  <fct>              <dbl>   <dbl>\n 1 Male   Conservative       0.607    3.67\n 2 Male   Labour             0.765    3.33\n 3 Male   Liberal Democrat   0.766    3.17\n 4 Male   Other party        0.703    3.83\n 5 Male   None               0.616    3.67\n 6 Male   Green Party        1.04     2.67\n 7 Female Conservative       0.565    3.67\n 8 Female Labour             0.781    3.33\n 9 Female Liberal Democrat   0.688    3.17\n10 Female Other party        0.773    3.67\n11 Female None               0.565    3.67\n12 Female Green Party        0.744    3   \n```\n\n\n:::\n:::\n\n\n\nWhen further broken down by gender, we can see that overall the same trends remain valid, with some nuances: male Green supporters are markedly more liberal than their female counterpart, the opposite being true among Conservative supporters. \n\nInstead of tables of summary statistics, we may want to have summary statistics computed as variables that will be added to the current dataset for each corresponding gender/political affiliation group. This is straightforward to do with dplyr, we just need to use the `mutate()` command.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbsa<-bsa%>%\n  group_by(Rsex.f,PartyId2.f)%>%\n  mutate(msscore=sd(libauth,na.rm=T),\n         mdscore=median(libauth,na.rm=T))\n```\n:::\n\n\nHowever, we also need to add the newly created variables into the existing bsa dataset, which the first line of the syntax above does. We can check that the variables have been created and that the correct values have been allocated to each sex/affiliation category.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(bsa)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Sserial\"          \"Rsex\"             \"RAgeCat\"          \"Married\"         \n [5] \"ChildHh\"          \"HEdQual3\"         \"eq_inc_quintiles\" \"RClassGp\"        \n [9] \"CCBELIEV\"         \"carallow\"         \"carreduc\"         \"carnod2\"         \n[13] \"cartaxhi\"         \"carenvdc\"         \"plnenvt\"          \"plnuppri\"        \n[17] \"Politics\"         \"Voted\"            \"actchar\"          \"actpol\"          \n[21] \"govnosa2\"         \"PartyId2\"         \"leftrigh\"         \"libauth\"         \n[25] \"WtFactor\"         \"PartyId2.f\"       \"Rsex.f\"           \"RAgeCat.f\"       \n[29] \"msscore\"          \"mdscore\"         \n```\n\n\n:::\n\n```{.r .cell-code}\nbsa[4:8,c(\"Rsex\",\"PartyId2\",\"mdscore\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 3\n  Rsex       PartyId2              mdscore\n  <dbl+lbl>  <dbl+lbl>               <dbl>\n1 2 [Female]  2 [Labour]              3.33\n2 1 [Male]    3 [Liberal Democrat]    3.17\n3 2 [Female] NA                       3.67\n4 1 [Male]    3 [Liberal Democrat]    3.17\n5 2 [Female]  6 [Green Party]         3   \n```\n\n\n:::\n:::\n\n\n\n\\newpage",
    "supporting": [
      "Descriptives_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}